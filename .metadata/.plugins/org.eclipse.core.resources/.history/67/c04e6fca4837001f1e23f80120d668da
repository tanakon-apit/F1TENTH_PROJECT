/*
 * BNO055.c
 *
 *  Created on: Apr 18, 2024
 *      Author: 08809
 */

#include "PAA5160E1.h"

/// @struct sfe_otos_pose2d_t
/// @brief 2D pose structure, including x and y coordinates and heading angle
/// @note Although pose is traditionally used for position and orientation, this
/// structure is also used for velocity and accleration by the OTOS driver
typedef struct
{
	/// @brief X value
	float x;

	/// @brief Y value
	float y;

	/// @brief Heading value
	float h;
} sfe_otos_pose2d_t;

/// @enum sfe_otos_linear_unit_t
/// @brief Enumerations for linear units used by the OTOS driver
typedef enum
{
	/// @brief Meters
	kSfeOtosLinearUnitMeters = 0,

	/// @brief Inches (default)
	kSfeOtosLinearUnitInches = 1
} sfe_otos_linear_unit_t;

/// @enum sfe_otos_angular_unit_t
/// @brief Enumerations for angular units used by the OTOS driver
typedef enum
{
	/// @brief Radians
	kSfeOtosAngularUnitRadians = 0,

	/// @brief Degrees (default)
	kSfeOtosAngularUnitDegrees = 1
} sfe_otos_angular_unit_t;

/// @union sfe_otos_version_t
/// @brief Version register bit fields
typedef union {
	struct
	{
		/// @brief Minor version number
		uint8_t minor : 4;

		/// @brief Major version number
		uint8_t major : 4;
	};

	/// @brief Raw register value
	uint8_t value;
} sfe_otos_version_t;

/// @union sfe_otos_signal_process_config_t
/// @brief Signal process config register bit fields
typedef union {
	struct
	{
		/// @brief Whether to use the internal lookup table calibration for the
		/// optical sensor
		uint8_t enLut : 1;

		/// @brief Whether to feed the accelerometer data to the Kalman filters
		uint8_t enAcc : 1;

		/// @brief Whether to rotate the IMU and optical sensor data by the
		/// heading angle
		uint8_t enRot : 1;

		/// @brief Whether to use the correct sensor variance in the Kalman
		/// filters, or use 0 varaince to effectively disable the filters
		uint8_t enVar : 1;

		/// @brief Reserved bits, do not use
		uint8_t reserved : 4;
	};

	/// @brief Raw register value
	uint8_t value;
} sfe_otos_signal_process_config_t;

/// @union sfe_otos_self_test_config_t
/// @brief Self test register bit fields
typedef union {
	struct
	{
		/// @brief Write 1 to start the self test
		uint8_t start : 1;

		/// @brief Returns 1 while the self test is in progress
		uint8_t inProgress : 1;

		/// @brief Returns 1 if the self test passed
		uint8_t pass : 1;

		/// @brief Returns 1 if the self test failed
		uint8_t fail : 1;

		/// @brief Reserved bits, do not use
		uint8_t reserved : 4;
	};

	/// @brief Raw register value
	uint8_t value;
} sfe_otos_self_test_config_t;

/// @union sfe_otos_status_t
/// @brief Status register bit fields
typedef union {
	struct
	{
		/// @brief Returns 1 if the tilt angle threshold has been exceeded.
		/// While set, the accelerometer data is ignored
		uint8_t warnTiltAngle : 1;

		/// @brief Returns 1 if the optical tracking is unreliable. While set,
		/// only the IMU data is used for tracking unless warnTiltAngle is set
		uint8_t warnOpticalTracking : 1;

		/// @brief Reserved bits, do not use
		uint8_t reserved : 4;

		/// @brief Returns 1 if the optical sensor has a fatal error
		uint8_t errorPaa : 1;

		/// @brief Returns 1 if the IMU has a fatal error
		uint8_t errorLsm : 1;
	};

	/// @brief Raw register value
	uint8_t value;
} sfe_otos_status_t;


// OTOS register map
#define kRegProductId 0x00;
#define kRegHwVersion 0x01;
#define kRegFwVersion 0x02;
#define kRegScalarLinear 0x04;
#define kRegScalarAngular 0x05;
#define kRegImuCalib 0x06;
#define kRegReset 0x07;
#define kRegSignalProcess 0x0E;
#define kRegSelfTest 0x0F;
#define kRegOffXL 0x10;
#define kRegOffXH 0x11;
#define kRegOffYL 0x12;
#define kRegOffYH 0x13;
#define kRegOffHL 0x14;
#define kRegOffHH 0x15;
#define kRegStatus 0x1F;
#define kRegPosXL 0x20;
#define kRegPosXH 0x21;
#define kRegPosYL 0x22;
#define kRegPosYH 0x23;
#define kRegPosHL 0x24;
#define kRegPosHH 0x25;
#define kRegVelXL 0x26;
#define kRegVelXH 0x27;
#define kRegVelYL 0x28;
#define kRegVelYH 0x29;
#define kRegVelHL 0x2A;
#define kRegVelHH 0x2B;
#define kRegAccXL 0x2C;
#define kRegAccXH 0x2D;
#define kRegAccYL 0x2E;
#define kRegAccYH 0x2F;
#define kRegAccHL 0x30;
#define kRegAccHH 0x31;
#define kRegPosStdXL 0x32;
#define kRegPosStdXH 0x33;
#define kRegPosStdYL 0x34;
#define kRegPosStdYH 0x35;
#define kRegPosStdHL 0x36;
#define kRegPosStdHH 0x37;
#define kRegVelStdXL 0x38;
#define kRegVelStdXH 0x39;
#define kRegVelStdYL 0x3A;
#define kRegVelStdYH 0x3B;
#define kRegVelStdHL 0x3C;
#define kRegVelStdHH 0x3D;
#define kRegAccStdXL 0x3E;
#define kRegAccStdXH 0x3F;
#define kRegAccStdYL 0x40;
#define kRegAccStdYH 0x41;
#define kRegAccStdHL 0x42;
#define kRegAccStdHH 0x43;

// Product ID register value
#define kProductId 0x5F;
